---
title: "R の強制型変換と NA の取り扱い"
author: "Koji Makiyama"
date: 2017-04-24T21:00:00-22:00
tags: ["R"]
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "hoxom01-"
)
```

## はじめに

R において欠損値を表す NA は非常に便利です。
NA は普通の R ユーザにとって自然に取り扱うことのできる概念ですが、それを支える内部の仕組みはわりと複雑です。
例えば、NA の型は論理値型ですが、一体それはなぜでしょうか？
今日は R における強制型変換の話とからめてその謎をひも解いていきます。

## ベクトルと型

R のベクトルは型を持ちます。

例えば、1から3までの数値ベクトルを作成してみます。

```{r}
x <- 1:3
x
```

ベクトルの型を確認するには `typeof()` 関数を使います。

```{r}
typeof(x)
```

ベクトル `x` の型は整数型(integer)であることがわかります。

他にも、例えば次のようなベクトルを作成してみます。

```{r}
x <- c("U", "NA", "DON")
x
typeof(x)
```

この場合、ベクトル `x` は文字列型(character)になります。

このように、Rのベクトルは必ず型を持ちます。

では、1つのベクトルの中に異なる型の要素を含めるとどうなるでしょうか。

```{r}
x <- c("U", 2, "DON")
x
typeof(x)
```

この場合、ベクトル `x` 中に含まれる数値の `2` は、文字列型の `"2"` に**強制型変換**されます。

## 強制型変換

R のベクトルは、1つだけしか型を持つことができません。[^1]

[^1]: もし、複数の型を持つベクトルが必要ならば、**リスト** を使うことになります。

したがって、異なる型の要素を結合してベクトルを作成しようとすると、型を統一するために、型の自動変換が行われます。これが強制型変換です。

強制型変換にはルールがあります。結合しようとする要素の型の中で、最も柔軟性の高い型に変換されます。

型の柔軟性は次の通りです。

```
logical < integer < double < complex < character
(論理値型 < 整数型 < 倍精度小数点型 < 複素数型 < 文字列型)
```

先ほどの例で言うと、`"U"` は character、`2` は double、`"DON"` は character なので、最も柔軟性の高い character 型に変換されたと言うわけです。

他の例を挙げると、例えば、整数型と論理値型を結合すると、整数型に強制型変換されます。[^2]

[^2]: 細かいことですが、R で `1` と書くと通常は倍精度小数点型とみなされます。整数型リテラルを表現するには `1L` のように数字の後に L を加える必要があります。

```{r}
x <- c(1L, 2L, 3L, TRUE, FALSE)
x
typeof(x)
```

複素数型と倍精度小数点型を結合すると、複素数型に強制型変換されます。

```{r}
x <- c(1 + 1i, 2 + 2i, 3, 4)
x
typeof(x)
```

おわかりのように、型の柔軟性は、低い方から高い方に自然に変換できるように決められています。

どんな型でも文字列に変換することができるので、文字列の型が最も柔軟性が高いことがわかります。

```{r}
x <- c(TRUE, 1L, 1.0, 1+0i, "hoge")
x
typeof(x)
```

## 強制型変換における NA の取り扱い

R には値が欠測していることを表すために NA という特別な値が用意されています。

```{r}
x <- c(1, NA, 3)
x
```

しかし、この NA の型を調べてみると、logical になっています。

```{r}
typeof(NA)
```

したがって、NA は論理値型であると思われるかもしれませんが、それは違います。

実は、Rでは、全部の型に対して NA が用意されています。

```{r echo=FALSE}
df <- data.frame(
  `型` = c("論理値型", "整数型", "倍精度小数点型", "複素数型", "文字列型"),
  type = sapply(list(TRUE, 1L, 1.0, 1+0i, "hoge"), typeof),
  "NA" = c("NA", "NA_integer_", "NA_real_", "NA_complex_", "NA_character_"),
  check.names = FALSE
)
knitr::kable(df)
```

その理由は強制型変換と深いつながりがあります。

まず、NA は最も柔軟性の低い論理値型で定義されています。

すなわち、論理値型のベクトルに NA が含まれている場合、強制型変換は行われません。

```{r}
x <- c(TRUE, NA, FALSE)
x
typeof(x)
```

次に、整数型のベクトルに NA を含めたいとします。
NA は論理値型ですので、整数型に強制型変換しなければなりません。
そこで使用されるのが整数型の NA である NA_integer_ というわけです。

```{r}
x <- c(1L, NA, 3L)
x
typeof(x)
```

表面上は NA と表示されますが、NA_integer_ に変換されていることは次のようにして確認できます。[^3]

[^3]: `identical()` は、オブジェクトが同じかどうかを判定する関数です。

```{r}
identical(x[2], NA)
identical(x[2], NA_integer_)
```

他の型でも同様に、NA は強制型変換のルールに従い、ベクトル中で最も柔軟性の高い型の NA に変換されます。

例えば、文字列型に含まれる NA は NA_character_ に変換されます。

```{r}
x <- c("U", NA, "DON")
x
identical(x[2], NA_character_)
```

デフォルトの NA が論理値型である理由は、ここにあります。

NA を柔軟性の最も低い論理値型とすることで、強制型変換のルールがうまく働き、最も自然な形で型変換を行うことができるのです。

## まとめ

デフォルトの NA が論理値型であることで、強制型変換のルールとうまく組み合わさり、自然な動きをすることがわかりました。

すべての型の NA は、`is.na()` を適用すると TRUE となります。

```{r}
sapply(list(NA, NA_integer_, NA_real_, NA_complex_, NA_character_), is.na)
```

したがって、ユーザは特に型を意識することなく NA を取り扱うことができます。

このように、便利な機能の裏側には様々な仕組みが動いています。

Rのこのような仕組みに興味を持った方は、参考文献に挙げた『R言語徹底解説』を読んでみてください。
Rの世界が広がると思います。

## 参考文献

- Hadley Wickham 著、石田基広、市川太祐、高柳慎一、福島真太朗 訳『R言語徹底解説』共立出版
- https://www.amazon.co.jp/dp/432012393X
